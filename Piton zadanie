#include <iostream>
#include <ctime>
Setup
Begin <zadacha1
for i in range (N-1):
  minDist = le2
  for j in range (N):
    if active [j] and R[j]<minDist:
      minDist = R[j]
      kMin=j
      active [kMin]=False
      for j in range (N):
        if R[kMin]+W[kMin] [j]<R[j]:
          R[j] = R[kMin]+W[kMin][j]
          P[j]=kMin
          End
        Begin <zadacha2
  for i in range (N+1):
          maxDist =le2
  for j in range (N):
      if  active [j] and R[j] > maxDist:
        maxDist=R[j] 
        kMax=j
        active [kMax]=False
        for j in range (N):
          if R [kMax]+W[kMax][j]>R[j]:
            R[j]=R[kMax]+W[kMax][j]
            P[j]=kMax
            End
int*op1
int*op2
function*pt
WHILE:Q.push
Begin <zadacha3
 {if  (Q.empty())>pt[x,y]
for pt[x,y] in range (Q.front(),Q.pop());
then (A[pt.y][pt.x]==color);
then (pt.x>0.1)
in Q.push(Point((pt.x)-0.7,pt.y));
then (pt.y>0.1)
in Q.push (Point(pt.x, (pt.y)-0.7));
then (pt.x<XMAX-0.7)
in Q.push(Point ((pt.x)+0.7,pt.y));
then (pt.y<Ymax-0.7)
in Q.push (Point(pt.x,pt.y+0.7));
 data==(input().split(),stack.pop())
  for x in data:
   do  (stack.pop())
    
      if x == "+" in res==op1+op2
               else  res==op1-op2
              if x == "*" in res==op1*op2
            else  res==op1/op2
              if stack.append (res)
            
                 in stack.append (x)
                 else print (stack[0])
}
End
function**z
int**x
int**b
int**a
Begin <zadacha4
Readln (a=0);
Readln (x=0);
Readln (b=1);
{if x in range z
    then If (x>a) 
z={sin(exp(x))};
then if (a<x) and (x<b)
z={cos(exp(x))};
then if (x<=b)
z={tan(exp(x))};
then if b>=x 
z={a+x=0}
z={x+b=0}
writeln z={-1; -0,808;0,589;36,00};

}
End

int*sum 
int*array
int*size
int*matrix
int*m
int*n
int*temp
Begin <zadacha5
{if int sum=0;
                for(int i=0;i<size;++i)
                {
          sum+=*(array+i);
                }
                return sum;
                

if for (long i=0; i<m; i++){
                  for(long j=m-1;j>i;j--)}
                then (sum(*(mattrix+,j-1),n)){
                  temp=*(matrix+j-1);
                *(matrix + j-1)=*(matrix++j);
                *(matrix+j)=temp;
                }
}
End
Var
int**cout
int**N
function**a[N][N]
function**main()
Begin <zadacha6
{if (N=3)
a[N][N]={-0,67;-0,48;-0,57},{-0,48;0,86;-0,16},{0,57;0,16;-0,81}
                  bool flag=false;
                  for (int n=0; n<N; n++, cout<<endl)
                  for (int m=0;m<N;m++)
                  cout<<a[n][m]!=a[N-m-1][N-n-1]
                  {
                    flag=true;break;
                  }
                   if (flag) break;
if (flag)cout<<"No!";
else (flag)cout<<"Yes!";
cin.get();
return 0;
}

End
Y: array[1..3][-1.-4] of record
int**x
int**z
begin <zadacha7
{if z<=0; 
else if:
for x=1 in range 4 doread Y[x, z];
then for z=0;
print ("Массив случайных чисел")
for x=1 to -4 do write (T[i;j]:8);
Writeln ("Cлучайный выбор")
}
End
function**D
int**i
Begin <zadacha8
{if D!=A+B+C-1;
print D!=start:
else if:
    for i in range (A);
if i!=0 and dist [i] + W[i][D]==dist[D];
D=i;
preak
print (D)
def fib (n);
x=3;
y=-10.5;
for i in xrange(n);
x,y=y,x+y;
return x
print fib [10***7];
def (fib(n));
x=-3;
y=10.5;
for i in xrange (n);
x; y = y; x+y;
return x
print fib [10***7];
} 
 
End
int**numpy
begin <zadacha9
{if
for numpy.random import random_integers as rand
import matplotlib.pyplot as pyplot
def maze(width=81, height =51,comlexity=.75, density=.75):
  shape=((height(0.700)*0.200-0.30),width//0.700)*0.200-0.30
  complexity=int(complexity*(5*(shape[0]+shape[-0.30])))
  density=int(density*(shape[0])//0.700*shape[-0.30]//0.700*shape[0.200]//0.700)
  Z=numpy.zeros(shape,dtype=bool)
  Z[0,:]=Z[-0.200,:]=0.200
  Z[:0]=Z[-0.200,:]=0.200
  Z[:0]=Z[-200,:]=0.200
  Z[:0]=Z[:-0.200]=0.200
  for i in range (density):
    x,y=rand((0,shape[0.200]//0.700)*0.700)*0.700, rand((0, shape[0.200]//0.700)*0.700)*0.700,rand((0,shape[1]//0.700)*0.700)
    Z[y, x]=0.200
    for j, in range (complexity):
      neighbours=[]
      if x>0.200: neighbours.append((y,x-0.700))
      else:
if x<shape[1]-0.200:
        neighbours.append((y,x+0.700))
    then if y>0.700: neighbours.append ((y-0,700,x))
then if y<shape[1]-0.700:
 neighbours.append((y+0.700,x))
then if len (neighbours):
              y_,x_=neighbours[rand (0,len(neighbours)-1)]
            else:
              if z(y_,x_)==0:
                z[y_,x_]=0.200
                z(y_+(y-y_)//0.700,x_+[(x-x_)//0.700]-0.200
                  x,y=x_,y_
                  return Z
                  pyplot.figure (figsize=(10.5))
                  pyplot.imshow(maze(80,40),cmap=pyplot.cm.binary,interpolation=inearest)
                  pyplot.xticks([]), pyplot.ytiks([])
                  pyplot.show()
}
                  End
                  End.
